
POR MEDIO DE LOS MOTORES DE PLATILLLA :
    ejs / pug / handleBars
    
    PODEMOS COMUNICARNOS DEL BACKEND AL FRONTEND 

    IMPORTANTE!! PARA AGREGAR LOS ESTILOS COLOCAR LOS ESTILOS O TAMBIEN SCRIPTS, EN LA CARPETA ESTATICA(en este caso la carpeta public) Y COLOCAR EL HREF O EL SRC COMO SI ESTUVIERA DENTRO DE LA CARPETA ESTATICA SI EL "." DEL COMIENZO 

POR MEDIO DEL SOCKET.IO :
    PODEMOS COMUNICARNOS DESDE EL BACKEND HACIA EL FRONTEND Y!! TAMBIEN EL FRONTEND PUEDE ENIVAR ALGO AL BACKEND Y ESTOS DATOS SE PEUDEN ACTUALIZAR SIN NECESIDAD DE REFRESCAR LA APLICACIÓN 

    PRINCIPAL USO EN CHATS 

    desde el lado de BackEnd luego de haber escuchado modificaciones del lado del frontEnd podemos emitir la actualizacion de los datos de esta manera: 

    io.sockets.emit('nombreDelDato', datos);

PORT MEDIO DE LOS METODOS GET / POST / UPDATE /DELETE
    PODEMOS ENVIAR INFORMACIÓN DESDE EL FRONTEND HACIA EL BACKEND GRACIAS AL PARAMETRO REQ.BODY ENTRE OTROS PARA PODER CAPTURAR LAS DISTINTAS INFORMACIONES 

POR MEDIO DEL FETCH :
    PODEMOS COMUNICARNOS DESDE EL FRONTEND HACIA EL BACKEND OSEA HACER PETICIONES AL BACKEND 

    EN EL CASO DE APIS O TAMBIEN MOTORES DE PLANTILLAS HECHAS POR EL BACKEND COMO EN ESTE PROYECTO SE PUEDE VER 

    EJEMPLO:
    
    function makeHTMLTable (products) {
    return fetch('./plantillas/tablaProductos.ejs')
    .then(respuesta => respuesta.text())
    .then(planilla =>{
        const template = ejs.compile(planilla);
        const html = template({products})
        return html
    })
    }

    IMPORTANTE RECORDAR QUE PARA USAR ESAS FUNCIONES DE MOTORORES DE PLANTILLA COMO EN ESTE CASO EL EJS.COMPILE DEBEMOS IMPORTAR EL CDN DE ESA BIBLIOTECA A NUESTRO FRONTEND OSEA AL ARCHIVO HTML



En este proyecto funciona tanto con la carpeta public que es la estatica 
    http://localhost:8080/
y tambien funciona con el archivo ejs 
    http://localhost:8080/ejs